class: CommandLineTool
cwlVersion: v1.0
$namespaces:
  sbg: 'https://www.sevenbridges.com'
id: tpp_peptideprophet_5_0_0
baseCommand: []
inputs:
  - id: input_file
    type: 'File[]'
    label: Input File
    doc: Input pepXML file
    'sbg:fileTypes': PEP.XML
outputs:
  - id: output_file
    doc: Output pepXML file
    label: Output File
    type: File?
    outputBinding:
      glob: |-
        ${
            var input_file = ''
            input_file = inputs.input_file[0].path
            input_file = input_file.split('/')[input_file.split('/').length - 1]
            var prefix = input_file.substring(0, input_file.indexOf('.pep'))
            var suf = input_file.substring(input_file.indexOf('.pep'), input_file.length)

            return prefix + '.peppro' + suf
        }
      outputEval: |-
        ${
            return inheritMetadata(self, inputs.input_file)

        }
    'sbg:fileTypes': PEP.XML
doc: >-
  **PeptideProphet** is a tool that automatically validates peptide assignments
  to MS/MS spectra made using database search programs such as SEQUEST. It is an
  integral part of the Trans-Proteomic Pipeline developed by the Seattle
  Proteome Center.


  PeptideProphet learns from each dataset distributions of search scores and
  peptide properties among correct and incorrect peptides and uses those
  distributions to compute for each result a probability that it is correct.
  Relevant peptide properties include the number of termini compatible with
  enzymatic cleavage (for unconstrained searches), the number of missed enzyme
  cleavages, the mass difference with respect to the precursor ion, the presence
  of light or heavy cysteine (for ICAT experiments), and the presence of an
  N-glycosylation motif (for N-glycosylation capture experiments).
  PeptideProphet can be used as a second step following the analysis of MS/MS
  spectra generated from any type of mass spectrometer and assigned peptides
  using any number of database search programs.


  ###Required Inputs


  1.  input_file: file in pepXML format that contains MS/MS spectra generated by
  database search programs

  2.  rtcat: catalog of measured peptide retention times based on
  Trans-Proteomic Pipeline-processed data


  ###Outputs


  1. output_file: file in pepXML format that contains a probability for every
  peptide-spectrum match (PSM) as well as the results of the modeling, including
  a representation of the receiver operating characteristic (ROC) curves



  ###Common Issues and Important Notes


  There are no known common issues.
label: TPP PeptideProphet
arguments:
  - position: 0
    shellQuote: false
    valueFrom: |-
      ${
          var cmd = ''
          var cmd2 = ''
          for (var i = 0; i < inputs.input_file.length; i++) {
            cmd += ' ln -s ' + inputs.input_file[i].path + ' . ; ';
            cmd2 += inputs.input_file[i].basename + ' ';
          }
          cmd += '/local/tpp/bin/PeptideProphetParser '
          return cmd + cmd2
       }
  - position: 1001
    shellQuote: false
    valueFrom: |-
      ${
          var input_file = ''
          if (inputs.input_file instanceof Array) {
              input_file = inputs.input_file[0].path
          } else {
              input_file = inputs.input_file.path
          }
          input_file = input_file.split('/')[input_file.split('/').length - 1]
          var prefix = input_file.substring(0, input_file.indexOf('.pep'))
          var suf = input_file.substring(input_file.indexOf('.pep'), input_file.length)

          var data = '; cp ' + input_file + ' ' + prefix + '.peppro' + suf
          return data
      }
requirements:
  - class: ShellCommandRequirement
  - class: ResourceRequirement
    ramMin: 2000
    coresMin: 2
  - class: DockerRequirement
    dockerPull: 'images.sbgenomics.com/vladimir_obucina/tpp:5.0.0'
  - class: InlineJavascriptRequirement
    expressionLib:
      - |-
        var updateMetadata = function(file, key, value) {
            file['metadata'][key] = value;
            return file;
        };


        var setMetadata = function(file, metadata) {
            if (!('metadata' in file))
                file['metadata'] = metadata;
            else {
                for (var key in metadata) {
                    file['metadata'][key] = metadata[key];
                }
            }
            return file
        };

        var inheritMetadata = function(o1, o2) {
            var commonMetadata = {};
            if (!Array.isArray(o2)) {
                o2 = [o2]
            }
            for (var i = 0; i < o2.length; i++) {
                var example = o2[i]['metadata'];
                for (var key in example) {
                    if (i == 0)
                        commonMetadata[key] = example[key];
                    else {
                        if (!(commonMetadata[key] == example[key])) {
                            delete commonMetadata[key]
                        }
                    }
                }
            }
            if (!Array.isArray(o1)) {
                o1 = setMetadata(o1, commonMetadata)
            } else {
                for (var i = 0; i < o1.length; i++) {
                    o1[i] = setMetadata(o1[i], commonMetadata)
                }
            }
            return o1;
        };

        var toArray = function(file) {
            return [].concat(file);
        };

        var groupBy = function(files, key) {
            var groupedFiles = [];
            var tempDict = {};
            for (var i = 0; i < files.length; i++) {
                var value = files[i]['metadata'][key];
                if (value in tempDict)
                    tempDict[value].push(files[i]);
                else tempDict[value] = [files[i]];
            }
            for (var key in tempDict) {
                groupedFiles.push(tempDict[key]);
            }
            return groupedFiles;
        };

        var orderBy = function(files, key, order) {
            var compareFunction = function(a, b) {
                if (a['metadata'][key].constructor === Number) {
                    return a['metadata'][key] - b['metadata'][key];
                } else {
                    var nameA = a['metadata'][key].toUpperCase();
                    var nameB = b['metadata'][key].toUpperCase();
                    if (nameA < nameB) {
                        return -1;
                    }
                    if (nameA > nameB) {
                        return 1;
                    }
                    return 0;
                }
            };

            files = files.sort(compareFunction);
            if (order == undefined || order == "asc")
                return files;
            else
                return files.reverse();
        };
