class: CommandLineTool
cwlVersion: v1.0
$namespaces:
  sbg: 'https://www.sevenbridges.com'
id: admin_sbg_public_data_tpp_peptideprophet_5_0_0_9
baseCommand: []
inputs:
  - 'sbg:category': Input Options
    'sbg:toolDefaultValue': 'False'
    id: accmass
    type: boolean?
    inputBinding:
      position: 73
      shellQuote: false
      valueFrom: |-
        ${
            if (inputs.accmass == true) {
                return 'ACCMASS'
            }
        }
    label: ACCMASS
    doc: use Accurate Mass model binning (default NO)
  - 'sbg:category': Input Options
    'sbg:toolDefaultValue': '0'
    id: clevel
    type: int?
    inputBinding:
      position: 107
      shellQuote: false
      valueFrom: |-
        ${
            if (inputs.clevel != undefined) {
                var data = inputs.clevel
                return 'CLEVEL=' + data
            }

        }
    label: CLEVEL
    doc: >-
      set Conservative Level in neg_stdev from the neg_mean, low numbers are
      less conservative, high numbers are more conservative (default 0)
  - 'sbg:category': Input Options
    id: decoy
    type: string?
    inputBinding:
      position: 121
      shellQuote: false
      valueFrom: |-
        ${
            if (inputs.decoy != undefined) {
                var data = inputs.decoy
                return 'DECOY=' + data
            }

        }
    label: DECOY
    doc: 'semi-supervised mode, protein name prefix to identify Decoy entries'
  - 'sbg:category': Input Options
    'sbg:toolDefaultValue': 'False'
    id: decoyprobs
    type: boolean?
    inputBinding:
      position: 91
      shellQuote: false
      valueFrom: |-
        ${
            if (inputs.decoyprobs == true) {
                return 'DECOYPROBS'
            }
        }
    label: DECOYPROBS
    doc: >-
      compute possible non-zero probabilities for Decoy entries on the last
      iteration(default False)
  - 'sbg:category': Input Options
    'sbg:toolDefaultValue': 'False'
    id: exclude
    type: boolean?
    inputBinding:
      position: 61
      shellQuote: false
      valueFrom: |-
        ${
            if (inputs.exclude == true) {
                return 'EXCLUDE'
            }
        }
    label: EXCLUDE
    doc: >-
      exclude deltaCn*, Mascot*, and Comet* results from results (default
      Penalize * results)
  - 'sbg:category': Input Options
    'sbg:toolDefaultValue': 'False'
    id: expectscore
    type: boolean?
    inputBinding:
      position: 97
      shellQuote: false
      valueFrom: |-
        ${
            if (inputs.expectscore == true) {
                return 'EXPECTSCORE'
            }
        }
    label: EXPECTSCORE
    doc: >-
      use expectation value as the only contributor to the f-value for modeling
      (default False)
  - 'sbg:category': Input Options
    'sbg:toolDefaultValue': 'False'
    id: forcedistr
    type: boolean?
    inputBinding:
      position: 103
      shellQuote: false
      valueFrom: |-
        ${
            if (inputs.forcedistr == true) {
                return 'FORCEDISTR'
            }
        }
    label: FORCEDISTR
    doc: >-
      bypass quality control checks, report model despite bad modelling (default
      False)
  - 'sbg:category': Input Options
    'sbg:toolDefaultValue': 'False'
    id: glyc
    type: boolean?
    inputBinding:
      position: 83
      shellQuote: false
      valueFrom: |-
        ${
            if (inputs.glyc == true) {
                return 'GLYC'
            }
        }
    label: GLYC
    doc: enable peptide Glyco motif model (default False)
  - 'sbg:category': Input Options
    'sbg:toolDefaultValue': 'False'
    id: icat
    type: boolean?
    inputBinding:
      position: 67
      shellQuote: false
      valueFrom: |-
        ${
            if (inputs.icat == true) {
                return 'ICAT'
            }
        }
    label: ICAT
    doc: apply ICAT model (default Autodetect ICAT)
  - id: input_file
    type:
      - File
      - type: array
        items: File
    inputBinding:
      position: 51
      shellQuote: false
    label: Input File
    doc: Input pepXML file
    'sbg:fileTypes': PEP.XML
  - 'sbg:category': Input Options
    'sbg:toolDefaultValue': 'False'
    id: instrwarn
    type: boolean?
    inputBinding:
      position: 89
      shellQuote: false
      valueFrom: |-
        ${
            if (inputs.instrwarn == true) {
                return 'INSTRWARN'
            }
        }
    label: INSTRWARN
    doc: >-
      ewarn and continue if combined data was generated by different instrument
      models (default False)
  - 'sbg:category': Input Options
    'sbg:toolDefaultValue': 'False'
    id: leave
    type: boolean?
    inputBinding:
      position: 63
      shellQuote: false
      valueFrom: |-
        ${
            if (inputs.leave == true) {
                return 'LEAVE'
            }
        }
    label: LEAVE
    doc: >-
      Leave alone deltaCn*, Mascot*, and Comet* results from results (default
      Penalize * results)
  - 'sbg:category': Input Options
    'sbg:toolDefaultValue': 'False'
    id: maldi
    type: boolean?
    inputBinding:
      position: 87
      shellQuote: false
      valueFrom: |-
        ${
            if (inputs.maldi == true) {
                return 'MALDI'
            }
        }
    label: MALDI
    doc: enable MALDI mode (default False)
  - 'sbg:category': Input Options
    'sbg:toolDefaultValue': '2'
    id: minpintt
    type: int?
    inputBinding:
      position: 109
      shellQuote: false
      valueFrom: |-
        ${
            if (inputs.minpintt != undefined) {
                var data = inputs.minpintt
                return 'MINPINTT=' + data
            }

        }
    label: MINPINTT
    doc: minimum number of NTT in a peptide used for positive pI model (default 2)
  - 'sbg:category': Input Options
    'sbg:toolDefaultValue': '0.9'
    id: minpiprob
    type: float?
    inputBinding:
      position: 111
      shellQuote: false
      valueFrom: |-
        ${
            if (inputs.minpiprob != undefined) {
                var data = inputs.minpiprob
                return 'MINPIPROB=' + data
            }

        }
    label: MINPIPROB
    doc: >-
      minimum probability after first pass of a peptide used for positive pI
      model (default 0.9)
  - 'sbg:category': Input Options
    'sbg:toolDefaultValue': '0.05'
    id: minprob
    type: float?
    inputBinding:
      position: 117
      shellQuote: false
      valueFrom: |-
        ${
            if (inputs.minprob != undefined) {
                var data = inputs.minprob
                return 'MINPROB=' + data
            }

        }
    label: MINPROB
    doc: report results with minimum probability number(default 0.05)
  - 'sbg:category': Input Options
    'sbg:toolDefaultValue': '2'
    id: minrtntt
    type: int?
    inputBinding:
      position: 113
      shellQuote: false
      valueFrom: |-
        ${
            if (inputs.minrtntt != undefined) {
                var data = inputs.minrtntt
                return 'MINRTNTT=' + data
            }

        }
    label: MINRTNTT
    doc: minimum number of NTT in a peptide used for positive RT model (default 2)
  - 'sbg:category': Input Options
    'sbg:toolDefaultValue': '0.9'
    id: minrtprob
    type: float?
    inputBinding:
      position: 115
      shellQuote: false
      valueFrom: |-
        ${
            if (inputs.minrtprob != undefined) {
                var data = inputs.minrtprob
                return 'MINRTPROB=' + data
            }

        }
    label: MINRTPROB
    doc: >-
      minimum probability after first pass of a peptide used for positive RT
      model (default 0.9)
  - 'sbg:category': Input Options
    'sbg:toolDefaultValue': 'False'
    id: neggamma
    type: boolean?
    inputBinding:
      position: 101
      shellQuote: false
      valueFrom: |-
        ${
            if (inputs.neggamma == true) {
                return 'NEGGAMMA'
            }
        }
    label: NEGGAMMA
    doc: use Gamma distribution to model the negative hits (default False)
  - 'sbg:category': Input Options
    'sbg:toolDefaultValue': 'False'
    id: noicat
    type: boolean?
    inputBinding:
      position: 69
      shellQuote: false
      valueFrom: |-
        ${
            if (inputs.noicat == true) {
                return 'NOICAT'
            }
        }
    label: NOICAT
    doc: do no apply ICAT model (default Autodetect ICAT)
  - 'sbg:category': Input Options
    'sbg:toolDefaultValue': 'False'
    id: nomass
    type: boolean?
    inputBinding:
      position: 77
      shellQuote: false
      valueFrom: |-
        ${
            if (inputs.nomass == true) {
                return 'NOMASS'
            }
        }
    label: NOMASS
    doc: disable mass model (default NO)
  - 'sbg:category': Input Options
    'sbg:toolDefaultValue': 'False'
    id: nonmc
    type: boolean?
    inputBinding:
      position: 95
      shellQuote: false
      valueFrom: |-
        ${
            if (inputs.nonmc == true) {
                return 'NONMC'
            }
        }
    label: NONMC
    doc: disable NMC missed cleavage model (default False)
  - 'sbg:category': Input Options
    'sbg:toolDefaultValue': 'False'
    id: nonparam
    type: boolean?
    inputBinding:
      position: 99
      shellQuote: false
      valueFrom: |-
        ${
            if (inputs.nonparam == true) {
                return 'NONPARAM'
            }
        }
    label: NONPARAM
    doc: >-
      use semi-parametric modeling, must be used in conjunction with DECOY=
      option (default False)
  - 'sbg:category': Input Options
    'sbg:toolDefaultValue': 'False'
    id: nontt
    type: boolean?
    inputBinding:
      position: 93
      shellQuote: false
      valueFrom: |-
        ${
            if (inputs.nontt == true) {
                return 'NONTT'
            }
        }
    label: NONTT
    doc: disable NTT enzymatic termini model (default False)
  - 'sbg:category': Input Options
    'sbg:toolDefaultValue': 'False'
    id: optimizefval
    type: boolean?
    inputBinding:
      position: 105
      shellQuote: false
      valueFrom: |-
        ${
            if (inputs.optimizefval == true) {
                return 'OPTIMIZEFVAL'
            }
        }
    label: optimizefval
    doc: >-
      (SpectraST only) optimize f-value function f(dot,delta) using PCA (default
      False)
  - 'sbg:category': Input Options
    'sbg:toolDefaultValue': 'False'
    id: perfectlib
    type: boolean?
    inputBinding:
      position: 65
      shellQuote: false
      valueFrom: |-
        ${
            if (inputs.perfectlib == true) {
                return 'PERFECTLIB'
            }
        }
    label: PERFECTLIB
    doc: multiply by SpectraST library probability (default False)
  - 'sbg:category': Input Options
    'sbg:toolDefaultValue': 'False'
    id: phospho
    type: boolean?
    inputBinding:
      position: 85
      shellQuote: false
      valueFrom: |-
        ${
            if (inputs.phospho == true) {
                return 'PHOSPHO'
            }
        }
    label: PHOSPHO
    doc: enable peptide Phospho motif model (default False)
  - 'sbg:category': Input Options
    'sbg:toolDefaultValue': 'False'
    id: pi
    type: boolean?
    inputBinding:
      position: 79
      shellQuote: false
      valueFrom: |-
        ${
            if (inputs.pi == true) {
                return 'PI'
            }
        }
    label: PI
    doc: enable peptide pI model (default False)
  - 'sbg:category': Input Options
    'sbg:toolDefaultValue': 'False'
    id: ppm
    type: boolean?
    inputBinding:
      position: 75
      shellQuote: false
      valueFrom: |-
        ${
            if (inputs.ppm == true) {
                return 'PPM'
            }
        }
    label: PPM
    doc: use ppm mass error instead of Daltons for mass modeling (default Daltons)
  - 'sbg:category': Input Options
    'sbg:toolDefaultValue': 'False'
    id: rt
    type: boolean?
    inputBinding:
      position: 81
      shellQuote: false
      valueFrom: |-
        ${
            if (inputs.rt == true) {
                return 'RT'
            }
        }
    label: RT
    doc: enable peptide RT model (default False)
  - 'sbg:category': Input Options
    id: rtcat
    type: File?
    inputBinding:
      position: 119
      shellQuote: false
      valueFrom: |-
        ${
            if (inputs.rtcat != undefined) {
                var data = inputs.rtcat.path
                return 'RTCAT=' + data
            }

        }
    label: RTCAT
    doc: >-
      enable peptide RT model, use <rtcatalog_file> peptide RTs when available
      as the theoretical value
  - 'sbg:category': Input Options
    'sbg:toolDefaultValue': 'False'
    id: zero
    type: boolean?
    inputBinding:
      position: 71
      shellQuote: false
      valueFrom: |-
        ${
            if (inputs.zero == true) {
                return 'ZERO'
            }
        }
    label: ZERO
    doc: report results with minimum probability 0 (default 0.05)
outputs:
  - id: output_file
    doc: Output pepXML file
    label: Output File
    type: File?
    outputBinding:
      glob: |-
        ${
            var input_file = ''
            if (inputs.input_file instanceof Array) {
                input_file = inputs.input_file[0].path
            } else {
                input_file = inputs.input_file.path
            }
            input_file = input_file.split('/')[input_file.split('/').length - 1]
            var prefix = input_file.substring(0, input_file.indexOf('.pep'))
            var suf = input_file.substring(input_file.indexOf('.pep'), input_file.length)

            return prefix + '.peppro' + suf
        }
      outputEval: |-
        ${
            return inheritMetadata(self, inputs.input_file)

        }
    'sbg:fileTypes': PEP.XML
doc: >-
  **PeptideProphet** is a tool that automatically validates peptide assignments
  to MS/MS spectra made using database search programs such as SEQUEST. It is an
  integral part of the Trans-Proteomic Pipeline developed by the Seattle
  Proteome Center.


  PeptideProphet learns from each dataset distributions of search scores and
  peptide properties among correct and incorrect peptides and uses those
  distributions to compute for each result a probability that it is correct.
  Relevant peptide properties include the number of termini compatible with
  enzymatic cleavage (for unconstrained searches), the number of missed enzyme
  cleavages, the mass difference with respect to the precursor ion, the presence
  of light or heavy cysteine (for ICAT experiments), and the presence of an
  N-glycosylation motif (for N-glycosylation capture experiments).
  PeptideProphet can be used as a second step following the analysis of MS/MS
  spectra generated from any type of mass spectrometer and assigned peptides
  using any number of database search programs.


  ###Required Inputs


  1.  input_file: file in pepXML format that contains MS/MS spectra generated by
  database search programs

  2.  rtcat: catalog of measured peptide retention times based on
  Trans-Proteomic Pipeline-processed data


  ###Outputs


  1. output_file: file in pepXML format that contains a probability for every
  peptide-spectrum match (PSM) as well as the results of the modeling, including
  a representation of the receiver operating characteristic (ROC) curves



  ###Common Issues and Important Notes


  There are no known common issues.
label: TPP PeptideProphet
arguments:
  - position: 0
    shellQuote: false
    valueFrom: /local/tpp/bin/PeptideProphetParser
  - position: 1001
    shellQuote: false
    valueFrom: |-
      ${
          var input_file = ''
          if (inputs.input_file instanceof Array) {
              input_file = inputs.input_file[0].path
          } else {
              input_file = inputs.input_file.path
          }
          input_file = input_file.split('/')[input_file.split('/').length - 1]
          var prefix = input_file.substring(0, input_file.indexOf('.pep'))
          var suf = input_file.substring(input_file.indexOf('.pep'), input_file.length)

          var data = '; mv ' + input_file + ' ' + prefix + '.peppro' + suf
          return data
      }
requirements:
  - class: ShellCommandRequirement
  - class: ResourceRequirement
    ramMin: 2000
    coresMin: 2
  - class: DockerRequirement
    dockerPull: 'images.sbgenomics.com/vladimir_obucina/tpp:5.0.0'
  - class: InitialWorkDirRequirement
    listing:
      - $(inputs.input_file)
  - class: InlineJavascriptRequirement
    expressionLib:
      - |-
        var updateMetadata = function(file, key, value) {
            file['metadata'][key] = value;
            return file;
        };


        var setMetadata = function(file, metadata) {
            if (!('metadata' in file))
                file['metadata'] = metadata;
            else {
                for (var key in metadata) {
                    file['metadata'][key] = metadata[key];
                }
            }
            return file
        };

        var inheritMetadata = function(o1, o2) {
            var commonMetadata = {};
            if (!Array.isArray(o2)) {
                o2 = [o2]
            }
            for (var i = 0; i < o2.length; i++) {
                var example = o2[i]['metadata'];
                for (var key in example) {
                    if (i == 0)
                        commonMetadata[key] = example[key];
                    else {
                        if (!(commonMetadata[key] == example[key])) {
                            delete commonMetadata[key]
                        }
                    }
                }
            }
            if (!Array.isArray(o1)) {
                o1 = setMetadata(o1, commonMetadata)
            } else {
                for (var i = 0; i < o1.length; i++) {
                    o1[i] = setMetadata(o1[i], commonMetadata)
                }
            }
            return o1;
        };

        var toArray = function(file) {
            return [].concat(file);
        };

        var groupBy = function(files, key) {
            var groupedFiles = [];
            var tempDict = {};
            for (var i = 0; i < files.length; i++) {
                var value = files[i]['metadata'][key];
                if (value in tempDict)
                    tempDict[value].push(files[i]);
                else tempDict[value] = [files[i]];
            }
            for (var key in tempDict) {
                groupedFiles.push(tempDict[key]);
            }
            return groupedFiles;
        };

        var orderBy = function(files, key, order) {
            var compareFunction = function(a, b) {
                if (a['metadata'][key].constructor === Number) {
                    return a['metadata'][key] - b['metadata'][key];
                } else {
                    var nameA = a['metadata'][key].toUpperCase();
                    var nameB = b['metadata'][key].toUpperCase();
                    if (nameA < nameB) {
                        return -1;
                    }
                    if (nameA > nameB) {
                        return 1;
                    }
                    return 0;
                }
            };

            files = files.sort(compareFunction);
            if (order == undefined || order == "asc")
                return files;
            else
                return files.reverse();
        };
